# -*- coding: utf-8 -*-
"""homework 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dzuR_4LcI8Y63XvDEMWstG-o_PXT9Jvy
"""

ciphertext = []
print("Please enter row transposition ciphertext \n")

ciphertext = str(input(''))

print(len(ciphertext))

key = 15 
rows = len(ciphertext)/key
print(rows)

print(str(key) + " columns\n" + str(rows) + ' rows\n' + str(len(ciphertext)) + ' characters')

# Python3 implementation of the
# above approach



# Function to string into grid form
def function(str, k):

	for i in range(len(str)):
		if i %k == 0:
			sub = str[i:i+k]
			lst = []
			for j in sub:
				lst.append(j)
			print(' '.join(lst))
   
#print(str(key) + " columns\n" + str(rows) + ' rows\n' + str(len(ciphertext)) + ' characters\n')
function(ciphertext, 15)
print("\n" + str(key) + " columns\n" + str(rows) + ' rows\n' + str(len(ciphertext)) + ' characters\n')


#import pandas as pd
#df = pd.read_csv( '/content/drive/MyDrive/NCAT - Grad School/COMP 726 - Network Security/Homework/homework 3/raj-hw3 - Sheet1.csv',header=None)

#df

#cols = df.columns.tolist()

#df.iloc[:, [2,4,5,0,12,11,10,9,6,7,8,3,14,13]]

# Program to print all combination
# of size r in an array of size n

# The main function that prints
# all combinations of size r in
# arr[] of size n. This function
# mainly uses combinationUtil()
def printCombination(arr, n, r):
	
	# A temporary array to
	# store all combination
	# one by one
	data = [0]*r;

	# Print all combination
	# using temporary array 'data[]'
	combinationUtil(arr, data, 0,
					n - 1, 0, r);

# arr[] ---> Input Array
# data[] ---> Temporary array to
#		 store current combination
# start & end ---> Starting and Ending
#			 indexes in arr[]
# index ---> Current index in data[]
# r ---> Size of a combination
# to be printed
def combinationUtil(arr, data, start,
					end, index, r):
						
	# Current combination is ready
	# to be printed, print it
	if (index == r):
		for j in range(r):
			print(data[j], end = " ");
		print();
		return;

	# replace index with all
	# possible elements. The
	# condition "end-i+1 >=
	# r-index" makes sure that
	# including one element at
	# index will make a combination
	# with remaining elements at
	# remaining positions
	i = start;
	while(i <= end and end - i + 1 >= r - index):
		data[index] = arr[i];
		combinationUtil(arr, data, i + 1,
						end, index + 1, r);
		i += 1;

# Driver Code
#arr = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14];
#r = 14;
#n = len(arr);
#printCombination(arr, n, r);



